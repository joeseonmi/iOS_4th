# 클래스와 구조체

- 오브젝티브C와 스위프트에서 클래스와 구조체는 문법적으로 차이가 없기때문에 헷갈리기가 쉽다
- **두개의 차이를 완벽하게 이해**하는게 목표
- 내 프로그램을 만드는데 쓸수있는 유연한 블럭이다.
- 프로퍼티와 메소드 클래스나 구조체에 추가할수있고 문법이 같다.
- 단일파일에 정의, 다른코드에서 자동으로 사용할수있다(접근제한자가 기본인터널)
- 초기상태를 설정하기위해 이니셜라이저가 만들어지고 커스텀가능
- 사용시 **인스턴스**라고 불린다.
- 프로토콜을 상속받아 사용할수있다. -> 정확하게표현하면 상속보다는 채택이라는 표현이 맞다

### 문법

```swift
class SomeClass {
		//클래스 내용
}

struct SomeStructure {
		//스트럭쳐 내용
}
```

### 프로퍼티를 넣는방법

```swift
struct Resolution {}var width = 0var height = 0class VideoMode {var resolution = Resolution()var interlaced = falsevar frameRate = 0.0var name: String?}
```

- 둘의 차이점: 클래스는 스트럭트의 프로퍼티를 만들 수 있다. 스트럭트는 클래스의 프로퍼티를 만들 수 없다.
- 프로퍼티 접근은 . 으로 할 수 있다.

## Initialization
- 인스턴스에 설정된 속성의 초기값설정 / 초기화하는 목적
- 클래스및 구조체는 인스턴스로 만들때 초기화해야된다. 초기화 안하면 옵셔널(옵셔널 자체도 nil로 초기화한거)
- 모든 **구조체**는 Memberwise Initializers가 만들어진다

```swift
struct Book {
    var name:String
    var cost:Int
    var isbn:UInt
}

class BookStore { //이니셜라이저의 문제로 여기는 에러뜸
    var books:[Book] = []
    var name:String
    var address:String
    
    init(name:String, address:String){
        self.name = name
        self.address = address
    }
    
    func addbook(name:String, cost:Int)
    {
        let book:Book = Book(name: <#T##String#>, cost: <#T##Int#>, isbn: <#T##UInt#>) //자동으로 들어옴(스트럭트는 이닛안해도 멤버와이즈로 기본으로 된다.커스텀한게 아니라 기본이 이거임!! 그래서 커스텀도 할 수있다.기본적으로 모든 프로퍼티에대해 만들어준다)
        self.books.append(book)
    }
}
```

## 클래스와 스트럭트의 차이점
- 클래스는 참조타입, 스트럭트는 값타입
	- **값타입 vs 참조타입**
- 클래스는 상속을 통해 부모클래스의 특성을 상속받을 수 있다. 스트럭트는 상속받을 수 없다.
- 클래스는 타입캐스팅을 할 수있다(스트럭트는 못함)
	- 우리가 썼던 타입캐스팅은 사실은 Int()-> 인스턴스를만들어서 인트를 초기화하고 거기다가 넣은거!
- 스트럭트의 프로퍼티는 인스턴스가 var를 통해서 만들어야 수정가능한다.
	- 스트럭트는 값을 복사해서 쓰기때문에 let으로 설정하면 쓸 수 없지만 클래스는 주소값을 참조하기때문에 let을 사용해도 상관없음
- 클래스는 <u>레퍼런스카운팅</u>을 통해 인스턴스의 해제를 계산한다(스트럭트는 안함)

> **레퍼런스카운팅**
> - ARC 오토레퍼런스카운팅의 개요
> 	- 힙에다가 어떤 인스턴스를 만들었을때 레퍼런스 카운팅이 1 된다.
> 	- 프로그램을 만들면서 레퍼런스카운팅이 증가/감소되는데 그과정에서 레퍼런스카운팅이 0이되면 힙에있는 객체는 파괴된다. 스트럭트는 데이터가 사라질때 메모리에서 데이터를 지워버린다. 이런걸 자동으로 해주는게 오토레퍼런스카운팅.
> 

- 클래스는 디이니셜라이저를 사용할수있다.(스트럭트는 사용못함)
- 스트럭트는 함수를 넣을수 없는데, 함수를 넣고싶으면 mutating이라는 키워드를 넣어주기로한다.

### 값타입 vs 참조타입
- 메모리구조
	- **코드영역:** 프로그램 코드 저장
	- **데이터영역:** 전역 변수, 정적변수가 저장(전역변수/스태틱 - 프로그램전체에서 인스턴스를 만들지 않고 바로바로 쓸 수 있다.)
	- **HEAP영역:** 동적 할당을 위한 영역(클래스의 인스턴스)
	- **스택영역:** 지역 변수(함수안에서 쓰이는 변수,클래스안의 프로퍼티 등), 매개변수 등 

- 값타입은 값이 복사되는데 주소값은 같은 주소를 참조한다(포인터)
	- let num1:Int = 5 	- let view:UIView = UIView()
 	- 일때 num1은 스택영역인데, view자체는 스택영영에있지만 UIview는 힙영역에있다. 이때 view의 값이 다른영역에 있어 정해줄수 없으니 힙영역에 있는 주소를 참조하게된다.

- 우리가 기본적으로 알고있는 값타입들은 다 스트럭트(Int, String등등)

## Deinit

```swift
class Student {    init() {//인스턴스 생성시 필요한 내용 구현 }deinit {//종료직전 필요한 내용 구현} }
```
- 인스턴스가 종료되기 직전(메모리에서 사라지기직전)에 실행된다.
- 클래스만 가능하다

### 어떤걸 써야할까?
- 애플가이드 (스트럭트를 써야할때)
	- 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
	- 캡슐화된 값이 참조되는 것보다 복사되는 것이 합당할 때
	- 구조체에 저장된 프로퍼티가 값타입이며 참조되는 것보다는 복 사되는 것이 합당할때
	- 다른 타입으로부터 상속받거나 자신이 상속될 필요가 없을 때(CGRect처럼 인스턴스인데 어떤역할도하지않는 값타입 등)

- 데이터모듈관련에서는 스트럭트로 빼버림
